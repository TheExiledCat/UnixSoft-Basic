{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"UnixSoft-BASIC official documentation","text":"<p>Welcome the offical documentation for the UnixSoft-BASIC project (USB)</p> <p>To get started see Getting started</p> <p>If you have any questions or bugs to report please had to the Github repo</p>"},{"location":"index.html#unixsoft-basic-usb","title":"UnixSoft BASIC (USB)","text":"<p>UnixSoft basic is a modern rendition of the AppleSoft BASIC language, written and compiled for linux x64.</p>"},{"location":"index.html#features","title":"Features","text":"<ul> <li>Scoped blocks:</li> </ul> <pre><code>    10 BEGIN //Start scope\n    20 LET X = 5\n    30 PRINT X\n    40 FIN // END scope\n    50 PRINT X //Out of scope variable error\n</code></pre> <ul> <li>Optional Line numbers:</li> </ul> <pre><code>    10 LET X = 5\n    PRINT X // linenumber inferred to be 11\n    PRINT X * 2 // linenumber inferred to be 12\n    11 PRINT X // duplicate line number error\n</code></pre> <ul> <li>Static Typing (for compilation purposes):</li> </ul> <pre><code>    LET X AS INTEGER\n    X = 5\n    X = \"Hello World\" // Type mismatch\n\n    LET Y = 10 //Type inferred\n    LET Z = 10 AS FLOAT // Type annotated with value\n</code></pre> <ul> <li>Comments (REM also still works):</li> </ul> <pre><code>    // This line is skipped\n    LET X = 5 // This left part is performed but this comment is skipped.\n</code></pre> <ul> <li>Easy FILE IO (cursor tracking text io using file descriptors):</li> </ul> <pre><code>    LET F = OPEN \"./file.txt\", \"rw\" // get file descriptor\n    LET C = READ F 1 // Read single 1 char from cursor onward\n    LET L = READLINE F // Get next line on cursor\n    LET A = READALL F // GET entire rest of file from cursor\n\n\n    WRITE F \"Hello\" // Overwrite the file with Hello\n    APPEND F \"Hello\" // Append to file\n    //ETC...\n</code></pre> <ul> <li>Easy terminal graphics:</li> </ul> <pre><code>    FCOLOR RED // set foreground color to red\n    BCOLOR #FFF // set background color to white, full rgb supported with compiler flag --color=24-bit\n    ICOLOR //invert background and foreground color\n    RCOLOR //reset color to default\n</code></pre> <ul> <li>and more :)</li> </ul>"},{"location":"index.html#vision","title":"Vision","text":"<p>My goal with this language is both to learn how to make a programming language for myself, but also to create a simple language easy to use for beginners, as BASIC was supposed to be as well. However i want a version of BASIC that matches the modern era, with modern features, and a modern syntax. I also want to make it easy to do more complex things without complicated syntax for people who want to make bigger applications</p> <p>For my full motivation see Personal vision</p>"},{"location":"index.html#documentation-and-guides","title":"Documentation and guides","text":"<p>For the full spec see USB</p>"},{"location":"USB.html","title":"UnixSoft-BASIC (USB) Reference","text":""},{"location":"USB.html#general-basics","title":"General basics","text":"<p>USB is a superset of AppleSoft BASIC. This means that most syntax specifics will be similar or the same to the AppleSoft variant, with small adjustments or additions here and there.</p> <p>Certain things are the same:</p> <pre><code>LET X = 5\n</code></pre> <p>While others are slightly different:</p> <pre><code>LET S$ = \"My age is \" + 23 //valid string, non string operands get stringified\n</code></pre> <p>However, most syntax hasnt changed. So when lost, you can also get away with using the original AppleSoft BASIC references.</p> <p>USB Keywords, identifiers and functions are case-insensitive. this means <code>print</code> is the same as <code>PRINT</code> and <code>LET X = 5; PRINT x</code> are valid USB</p>"},{"location":"USB.html#grammar","title":"Grammar","text":"<p>The core of the USB syntax is split into 2 types of symbols:</p> <ul> <li>Expressions</li> <li>Statements</li> </ul> <p>These expand into the following:</p> <ul> <li>Expressions<ul> <li>arithmic expressions or identifiers (<code>x + y, 10 - 20 ...</code>)</li> <li>function calls, constants or variables(<code>ABS(x), y, 10, \"Hello\" ...</code>)</li> <li>conditionals (<code>x &lt; 10, b == FALSE, ...</code>)</li> <li>More...</li> </ul> </li> <li>Statements<ul> <li>Assignments (<code>LET X = 10</code>)</li> <li>Keywords (<code>PRINT, FOR, IF ...</code>)</li> <li>Function calls</li> <li>Definitions (<code>DEF MyLambda x, y = x * y</code>)</li> <li>More...</li> </ul> </li> </ul>"},{"location":"USB.html#differences-from-applesoft-basic","title":"Differences from AppleSoft-BASIC","text":"<p>USB differs from applesoft basic in some fundamental areas, however, most AppleSoft Syntax is still mostly supported for legacy reasons. A lot of redundant functionality has been either added on top of. Or an alternative has been added.</p>"},{"location":"USB.html#changes","title":"Changes:","text":"<ul> <li> <p>Optional linenumbers</p> <pre><code>    10 PRINT X // numbered lines\n    LET A = 10 // Line inferred by position (11)\n    LET B = 20 // Same here (12). In a fully unnumbered file the line numbers start at 1\n</code></pre> </li> <li> <p>Note this does come with a drawback for the compilers resolver:</p> <pre><code>    10 PRINT X //(10)\n    LET A = 10 //(11) Inferred\n    11 PRINT Y //(11) Compiler error: duplicate statement\n</code></pre> </li> <li> <p>Scopes:</p> <pre><code>BEGIN\nLET X = 5\nPRINT X\nFIN\n\nPRINT X //undefined token error\n</code></pre> <pre><code>IF X &lt; 5 BEGIN\n// statements....\nFIN\n</code></pre> </li> <li> <p><code>;</code> instead of <code>:</code> for statement seperating</p> <pre><code>LET X = 10; PRINT X\n</code></pre> </li> <li> <p>Note: A single statement cant be spread over multiple lines, Commands are defined as a single line till <code>\\n</code> or a <code>;</code> seperated list of statements</p> </li> </ul>"},{"location":"USB.html#statements","title":"Statements","text":""},{"location":"USB.html#variable-control","title":"Variable Control","text":"<ul> <li> <p>NOTE: LET, DEF and DIM:</p> <ul> <li>Assignments using <code>=</code>can only be used on variables already created using their respective keyword, you can NOT assign as declaration. E.g. <code>X = 5</code>without using <code>LET X</code> beforehand. This will throw a undefined variable error on compilation</li> </ul> </li> <li> </li> <li> </li> </ul>"},{"location":"USB.html#clear","title":"CLEAR","text":"<ul> <li>Syntax: <code>CLEAR</code></li> <li>Clear all global static variables</li> <li>Note that 'Clearing' in USB means resetting the variables to their default values (e.g. 0 for numbers, \"\" for strings)</li> <li> <p>Example:</p> <pre><code>LET X = 10\nLET Y = TRUE\n\nCLEAR\n\nPRINT X\nPRINT Y\n</code></pre> <p>Output</p> <pre><code>0\nFALSE\n</code></pre> </li> </ul>"},{"location":"USB.html#cscope","title":"CSCOPE","text":"<ul> <li>Syntax: <code>CLEAR</code></li> <li><code>Same as above, but only clears variables in the current scope</code></li> <li> <p>Example:</p> <pre><code>LET X = 10\n\nBEGIN\nLET Y = 20\nCSCOPE\nPRINT X\nPRINT Y\n</code></pre> <p>Output:</p> <pre><code>10\n0\n</code></pre> </li> </ul>"},{"location":"USB.html#dim","title":"DIM","text":"<ul> <li>Syntax: <code>DIM &lt;name&gt; (columns [,rows]) [AS &lt;DATATYPE&gt;]</code></li> <li>Define array with specified width and height (or single dimension if left empty) .</li> <li>Infers datatype when assigned if not annotated.</li> <li> <p>Example:</p> <pre><code>DIM arr(10) AS INTEGER // define an  integer array, containing only 10 0's\narr[0] = 100\nPRINT arr[0]\n\n//Inferred type\nDIM arr1(10)\narr1[0] = 100\nPRINT TYPE (arr1[0]) // prints INTEGER\n\n//Indexing multiple dimensions:\nDIM arr2(10, 10) AS INTEGER\narr2[0][0] = 100 //First array stores the rows, second indexer selects a column from that row\n</code></pre> </li> </ul>"},{"location":"USB.html#def","title":"DEF","text":"<ul> <li>Syntax: <code>DEF &lt;name&gt; [param1, param2 , ...] = &lt;expression&gt;</code></li> <li>Define a lambda function. This lambda can only return a single datatype.</li> <li>Example:     <pre><code>DEF square x = x*x\nPRINT square(5) // prints 25\n</code></pre></li> </ul>"},{"location":"USB.html#let","title":"LET","text":"<ul> <li>Syntax: <code>LET {&lt;name&gt; | &lt;name&gt; = &lt;expression&gt; | &lt;name&gt; AS &lt;DATATYPE&gt; | &lt;name&gt; = &lt;expression&gt; AS &lt;DATATYPE&gt;}</code></li> <li>Declare and optionally assign a new variable.     Infers datatype if not annotated.</li> <li> <p>Example:</p> <pre><code>LET X = 10 // Declare and assign, Infers datatype\n\nLET Y AS FLOAT = 10 // Declare and assign with datatype\n//or\nLET Y = 10 AS FLOAT // Declare and assign with datatype\n\nLET Z AS FLOAT //Default value of datatype is assigned, e.g. 0.0\n</code></pre> </li> </ul>"},{"location":"USB.html#type","title":"TYPE","text":"<ul> <li>Syntax: <code>TYPE &lt;expression&gt;</code></li> <li>Returns the type of the expression as a string, mostly used for debugging purposes</li> <li>This is a compile time operation as it only works on expressions with a known return type at compile time. It just stores the type annotation as a constant string.</li> <li>Example     <pre><code>LET X = 5\nLET Y - TYPE (X) // Gets replaced with INTEGER at compile time\nPRINT Y //INTEGER\n</code></pre></li> </ul>"},{"location":"USB.html#enum","title":"ENUM","text":"<ul> <li>Syntax: <code>ENUM &lt;name&gt; = &lt;key1 [value1]&gt; [, ...]</code></li> <li>Define a C style enum where every key is mapped to a constant integer value</li> <li>The values for each key can be inferred (starting at 0) but must be annotated if the order is not sequential</li> <li>Example:     <pre><code>ENUM direction = UP, DOWN, LEFT, RIGHT // 0, 1, 2, 3\nENUM job = FASTFOOD 2, TEACHER, DOCTOR // 2, 3, 4\nENUM class = ROGUE 2, WARRIOR 5 , MAGE // 2, 5, 6\nENUM color = CYAN 2, GREEN 0, BLUE // Error, value must be given if not sequential\n</code></pre></li> <li>Note: Enums in USB are nothing but named integers. that means that you can use them in any place where an integer is expected. Enums are not a type, just syntactic sugar. whenever a value is annotated with <code>AS &lt;MYENUM&gt;</code> it will just become an integer with the value of the enum. Default values of enum typed variables are the first keys value in the enum. Casting between integers and enum types is implicit</li> </ul>"},{"location":"USB.html#flow","title":"Flow","text":""},{"location":"USB.html#goto","title":"GOTO","text":"<ul> <li>Syntax: <code>GOTO { linenumber | alias, linenumber }</code></li> <li>Jump to the specified line or line in a file imported using alias</li> <li> <p>Example (Prints the current date and time to the console permanently):</p> <pre><code>10 PRINT DATE\nGOTO 10\n\n// used with an alias\nIMPORT \"my_lib.usb\" AS MYLIB\nGOTO MYLIB, 10\n\n//my_lib.usb\n10 PRINT \"Hello from my_lib.usb\"\n</code></pre> </li> </ul>"},{"location":"USB.html#gosub","title":"GOSUB","text":"<ul> <li>Same as <code>GOTO</code> but push onto the function stack and jump to sub routine. Expects a <code>RET</code> or <code>END</code> somewhere in the Sub routine</li> <li><code>RET</code> can not return a value when using <code>GOSUB</code>. However global variables can be edited by the subroutine. For proper functions see <code>FN</code></li> <li> <p>Example:</p> <pre><code>10 GOSUB 30\n20 PRINT \"BYE\"\n\n30 LET X$ = INPUT \"Fill in your name\\n&gt; \"\n40 PRINT \"Hello \" + X$\n50 RET\n</code></pre> <p>Output:</p> <pre><code>Fill in your name\n&gt; John\nHello John\nBYE\n</code></pre> </li> </ul>"},{"location":"USB.html#ret","title":"RET","text":"<ul> <li>Syntax: <code>RET [expression]</code></li> <li>Return from a subroutine or function</li> <li>Pops from the call stack and returns to the line Popped</li> <li>When used with functions can optionally return a value</li> </ul>"},{"location":"USB.html#menu","title":"MENU","text":"<ul> <li>Syntax: <code>MENU &lt;expression&gt; {&lt;statement1&gt; [,&lt;statement2&gt; ,...] | {GOTO | GOSUB } linenumber1 [ , linenumber2, ...}</code></li> <li>A modern replacement of the <code>ON</code>command from applesoft.</li> <li>When used with an expression, calls one of the statements given where expression's value is the index of the statement to use (1 based)</li> <li>When used with either a <code>GOTO</code>or a <code>GOSUB</code> statement, instead pass a comma seperated list of linenumbers (can be aliased) to jump to.</li> <li>Example:     <pre><code>LET X = INT(INPUT \"Fill in a number from 1 - 3\\n&gt; \")\nMENU X PRINT \"Hello\", GOTO 10, GOSUB 20\nor\nMENU X GOTO 10, 20, 30\n</code></pre></li> </ul>"},{"location":"USB.html#for","title":"FOR","text":"<ul> <li>Syntax: <code>FOR &lt;temp-var&gt; = &lt;expression&gt;, &lt;condition&gt;, &lt;step-action&gt; = &lt;statement&gt; { [statement1 [, statement2, ...] NEXT] | &lt;scope&gt;}</code></li> <li> <p>starts a C-style for loop.</p> </li> <li> <p>after the paramaters for the for loop are given can either call any statements until a <code>NEXT</code> call or given a Scope which will automatically call <code>NEXT</code> at the end.</p> </li> <li>Example:     <pre><code>FOR I = 0, i &lt; 10, I += 1\nPRINT I\nNEXT\n</code></pre></li> </ul>"},{"location":"USB.html#for_1","title":"FOR","text":"<ul> <li>Syntax: <code>&lt;temp-var&gt; = &lt;number-expression&gt; TO &lt;number target&gt; [STEP stepsize] {statement1 [, statement2, ...] NEXT | &lt;scope&gt;}</code></li> <li> <p>Original Applesoft for loop. can be used with both floats and integers.</p> </li> <li> <p>Also supports scopes or next like the C style loop</p> </li> <li> <p>Example:</p> <pre><code>FOR I = 0 TO 10 STEP 1\nPRINT I\nNEXT\n</code></pre> </li> </ul>"},{"location":"USB.html#next","title":"NEXT","text":"<ul> <li>Syntax <code>NEXT [count]</code></li> <li> <p>Forces a loop to continue from its start with its step incremented count times. If no count is given, it will increment by 1 or the loops STEP value.</p> </li> <li> <p>when used with for loops, count can be used to specify how many times to call the step size or the C style end of loop statement. If a negative value is given a runtime error will occur</p> </li> <li> <p>will error if used outside of a loop context.</p> </li> <li> <p>Example:</p> <pre><code>FOR I = 0 TO 10 STEP 1\nPRINT I\nIF I &gt; 5 THEN NEXT 3 // increment I by 3 * STEP\nNEXT\n</code></pre> </li> </ul>"},{"location":"USB.html#if","title":"IF","text":"<ul> <li>Syntax: <code>IF &lt;expression&gt; {THEN &lt;statement&gt; | GOTO | GOSUB | &lt;scope&gt;}</code></li> <li> <p>if expression is true perform the following:</p> <ul> <li> <p>THEN: perform a single statement</p> </li> <li> <p>GOTO or GOSUB: jump to a line using the logic in GOTO or GOSUB</p> </li> <li> <p>IF can also be given a scope using <code>BEGIN</code>and <code>FIN</code> to call when the if statement is true</p> </li> <li>Example:     <pre><code>LET X = 10\nIF X &gt;= 5 THEN PRINT X\nIF X &gt;= 5 GOTO 100\nIF X &gt;= 5 GOSUB 100\nIF X &gt;= 5 BEGIN\nPRINT X\nPRINT X * 2\nFIN\n</code></pre></li> </ul> </li> </ul>"},{"location":"USB.html#end","title":"END","text":"<ul> <li> <p>Terminate the program early and cleanly with a 0 statuscode</p> </li> <li> <p>Every script has an invisible <code>END</code> at the end of it. Hence this is mostly used for early returns</p> </li> <li>Example:     <pre><code>LET X = 10\nIF X &gt;= 5 THEN END\nPRINT X\n</code></pre></li> </ul>"},{"location":"USB.html#stop","title":"STOP","text":"<ul> <li>Syntax: <code>STOP &lt;errorcode&gt;</code></li> <li>Terminate the program early with the given error code</li> <li>Example:     <pre><code>LET X = INT(\"10q\") // format error, ERR gets value mapped to that\nIF ERR &gt; 0 STOP ERR // Terminate program with error code\nPRINT X\n</code></pre></li> </ul>"},{"location":"USB.html#error-handling","title":"Error Handling","text":"<p>Error handling in USB is a bit different from other programming languages. It uses a special variable called <code>ERR</code> to store the error code . The <code>ERR</code> variable can be used to check if an error occurred and what the error code is. The <code>ERR</code> variable is automatically set to the error code when an error occurs.</p> <p>Instead of a recursive backtracking approach to errors where nested scopes are unwound, errors in USB are global and linear. This means that handling errors in USB is a bit simpler and limited than other languages.</p> <p>Heres how to write error handlers and create your own errors:</p>"},{"location":"USB.html#onerr","title":"ONERR","text":"<ul> <li>Syntax: <code>ONERR &lt;statement&gt;</code></li> <li>Sets the current error handler to a given statement. If a built in function throws an error or the <code>THROW</code> keyword is used, the error handler is called and the error code is passed into the <code>ERR</code> global variable</li> <li> <p>Example (Retry mechanism for input):</p> <pre><code>5 ONERR PRINT ERR, GOTO 10\n10 LET X = INT(INPUT \"Fill in a number\\n&gt; \") // if format error, ERR gets value mapped to that\n20 PRINT X\n</code></pre> </li> <li> <p>Note: ONERR is nothing but a label for a statement, whenever THROW is used, GOSUB ONERR is called. If ONERR is a single statement the RET at the end is inferred, otherwise a RET is needed.</p> </li> </ul>"},{"location":"USB.html#throw","title":"THROW","text":"<ul> <li>Syntax: <code>THROW &lt;code&gt;</code></li> <li>Trigger the <code>ONERR</code> handler and store code into <code>ERR</code></li> <li>code must be a positive integer greater than 0</li> <li>Example:     <pre><code>ONERR PRINT \"Something went wrong. Errorcode: {}\", ERR\nLET X = 5\nIF X &lt; 10 THEN THROW 100\n// after ONERR is called, program continues here\n</code></pre></li> </ul>"},{"location":"USB.html#user-io","title":"User I/O","text":""},{"location":"USB.html#print","title":"PRINT","text":"<ul> <li>Syntax: <code>PRINT { &lt;format&gt; [, &lt;expression&gt; ...] | &lt;expression&gt; }</code></li> <li>Prints the given expression(s) to the console. If a format is given, it is used to     format the output, replacing any <code>{}</code>s with the expression(s) given from left to right.</li> <li> <p>Example:</p> <pre><code>LET Name$ = \"Kevin\"\nPRINT \"Hello {}!\", Name$\n</code></pre> <p>Output:</p> <pre><code>Hello Kevin!\n</code></pre> </li> </ul>"},{"location":"USB.html#penum","title":"PENUM","text":"<ul> <li>Syntax: <code>PENUM &lt;ENUM&gt;, &lt;expression&gt;</code></li> <li>Prints the given expression as if it were part of an enumeration.</li> <li>Will throw an error if used on a non number value. floats are rounded down before checked.</li> <li>Example:     <pre><code>ENUM direction = NORTH, EAST, SOUTH, WEST\nLET X = NORTH\nPRINT X // 0\nPENUM direction, X // NORTH\n</code></pre></li> <li>Note: <code>PENUM</code> generates an array of strings at compile time storing every stringified version of the enum value. This array is then used at runtime to print the correct string. If you used no PENUM calls in your code or on a specific enum, this array is not generated for that code or enum. You can use this fact to reduce binary size</li> </ul>"},{"location":"USB.html#poptions","title":"POPTIONS","text":"<ul> <li>Syntax: <code>POPTIONS &lt;OPTION&gt;, &lt;expression&gt; [,expression, ...] &lt;prompt&gt;</code></li> <li>Presents the user with a menu of options, allowing them to select one by entering its number. The last argument is the prompt to display under the menu.</li> <li>Works similar to INPUT under the hood, returning the value of the chosen option, but as an integer so it can be used with <code>MENU</code> very easily.</li> <li>Example: See Creating a menu</li> </ul>"},{"location":"USB.html#input","title":"INPUT","text":"<ul> <li>Syntax: <code>INPUT [prompt]</code></li> <li>Reads a line from <code>STDIN</code></li> <li>Can be given an optional prompt to show the user</li> <li>Hangs till input is given</li> <li>Used as a function, returns the line read from <code>STDIN</code></li> <li> <p>Example:</p> <pre><code>LET X$ = INPUT \"Enter a number\"\nPRINT X$\n</code></pre> <p>Output:</p> <pre><code>Enter a number\n&gt; 5\n5\n</code></pre> </li> </ul>"},{"location":"USB.html#get","title":"GET","text":"<ul> <li>Syntax: <code>GET [prompt]</code></li> <li>Reads a single key from <code>STDIN</code></li> <li>Hangs till input is given</li> <li>Optionally prints the prompt first</li> <li>Returns the pressed key as a single character string the moment it is pressed.</li> <li>Example:     <pre><code>LET X$ = GET \"Press any key to continue (q to quit)\"\nIF X$ == \"q\" THEN END\n// ... other code\n</code></pre></li> </ul>"},{"location":"USB.html#home","title":"HOME","text":"<ul> <li>Syntax: <code>HOME</code></li> <li>Clears the screen</li> </ul>"},{"location":"USB.html#htab-and-vtab","title":"HTAB and VTAB","text":"<ul> <li>Syntax: <code>HTAB &lt;expression&gt;</code> or <code>VTAB &lt;expression&gt;</code></li> <li>Sets the horizontal or vertical position of the cursor on the <code>STDOUT</code> buffer.</li> <li>top left is (0,0)</li> <li>Values greater than the screen size are clamped to the size of the screen</li> <li>To see the size of the screen buffer, see <code>SCREEN</code> command</li> </ul>"},{"location":"USB.html#flash","title":"FLASH","text":"<ul> <li>Syntax: <code>FLASH &lt;expression&gt;</code></li> <li>Sets the cursor flash to the boolean evaluation of the expression</li> </ul>"},{"location":"USB.html#graphics","title":"GRAPHICS","text":"<p>-</p>"},{"location":"USB.html#date-and-time","title":"Date and Time","text":"<p>Since the original Applesoft BASIC language was very limited to the hardware it ran on, date and time functionality wasnt really that great.</p> <p>USB build on that in a simple but still usable way:</p>"},{"location":"USB.html#date","title":"DATE","text":"<ul> <li>Syntax: <code>DATE</code></li> <li>Get the current date and time (Unix epoch) as an integer</li> <li>Example:     <pre><code>LET now = DATE\nPRINT now // e.g. 1643723900\n</code></pre></li> <li>Note: Casting a date to a string using <code>STR()</code> will default to the format <code>YYYY-MM-DD HH:MM:SS</code></li> </ul>"},{"location":"USB.html#time","title":"TIME","text":"<ul> <li>Get the current time of the day as a float storing the hour value (0-24)</li> <li>Example:     <pre><code>LET now = TIME\nPRINT now // e.g. 12.5 for 12:30\n</code></pre></li> <li>Note: Casting a time to a string using <code>STR()</code> will default to the format <code>HH:MM</code>. When used as a cast <code>TIME()</code> will return the time of a <code>DATE</code> integer</li> </ul>"},{"location":"USB.html#day-or-hour-or-minute-or-second","title":"DAY or HOUR or MINUTE or SECOND","text":"<ul> <li>Helper functions to create a date integer storing a date offset</li> <li>Example:     <pre><code>LET tommorow = DATE + DAY 1\n</code></pre></li> </ul>"},{"location":"getting-started.html","title":"Getting Started","text":""},{"location":"getting-started.html#about","title":"About","text":"<p>USB is meant to be a modern rendition on AppleSoft-BASIC, this means that just like applesoft, USB is meant mostly as a learning ground for new programmers to program in a very simple language while still being able to use it for scripting later on.</p>"},{"location":"getting-started.html#installation","title":"Installation","text":"<p>USB can be installed using either the source code and the <code>cargo</code> toolchain or by downloading one of the preinstalled binaries from the <code>release</code> page and adding it to <code>PATH</code></p>"},{"location":"getting-started.html#verify-installation","title":"Verify installation","text":"<p>To verify the installation, run:</p> <pre><code>usbasic version\n</code></pre> <p>You should see the installed version printed to stdout</p>"},{"location":"getting-started.html#your-first-usb-project","title":"Your first USB project","text":"<p>usbasic is not just a compiler, its also a fully fledged cli tool used to create projects, install tools and more.</p> <p>To create a project:</p> <pre><code>usbasic init &lt;directory&gt;\n</code></pre> <p>This will create the following directory and its structure if given (can also be used in an existing directory):</p> <ul> <li> <p><code>/directory/</code></p> <ul> <li> <p><code>src/</code></p> <ul> <li><code>main.usb</code></li> </ul> </li> <li> <p><code>obj/</code></p> </li> <li> <p><code>build/</code></p> </li> <li> <p><code>&lt;directoryname&gt;.usbp.json</code></p> </li> <li> <p><code>.gitignore</code></p> </li> </ul> </li> </ul>"},{"location":"getting-started.html#folder-structure-explained","title":"Folder structure explained","text":"<p>The folders above have the following responsibilities:</p> <ul> <li> <p><code>src</code>:</p> <ul> <li>Stores all your USB scripts.</li> <li>The default usbp config will set <code>src/main.usb</code> as the default entrypoint for <code>usbasic build</code></li> </ul> </li> <li> <p><code>obj</code>:</p> <ul> <li>Stores temporary files used during building (like <code>.o</code> , <code>.asm</code> files and more)</li> </ul> </li> <li> <p><code>build</code>:</p> <ul> <li>Stores the actual final binary</li> </ul> </li> <li> <p><code>.usbp.json</code></p> <ul> <li>This is the config file for USB projects</li> <li>This stores configuration settings, dependencies and more.</li> </ul> </li> <li> <p><code>.gitignore</code></p> <ul> <li>Default gitignore ignoring the <code>obj</code> and <code>build</code> dirs</li> </ul> </li> </ul>"},{"location":"guide.html","title":"USB Guide","text":"<p>This chapter of the documentation shows you common design patterns and how to use the USB language.</p>"},{"location":"guide.html#creating-a-selection-menu","title":"Creating a selection menu","text":"<p>Getting structured user input is one of the most fundamental parts of terminal based applications. The USB language provides a simple way to create a selection menu.</p> <pre><code>LET choice = POPTIONS \"Schedule a meeting\", \"Edit a meeting\", \"Cancel a meeting\", \"Quit\", \"Please select an option from the list above\"\n</code></pre> <p>This will prompt the user with the following list:</p> <pre><code>1. Schedule a meeting\n2. Edit a meeting\n3. Cancel a meeting\n4. Quit\nPlease select an option from the list above\n&gt;\n</code></pre> <p>this will internally store the user's choice in the <code>choice</code> variable as an integer.</p> <p>If the choice value is not an integer or outside of the range of options, THROW will be called with a <code>Format</code> or an <code>OutOfRange</code> error.</p> <p>Then to match the chosen option:</p> <pre><code>MENU choice PRINT \"You scheduled a new meeting\", PRINT \"You edited a meeting\", PRINT \"You cancelled a meeting\", END\n</code></pre> <p>This will perform the corresponding statements.</p> <p>Output:</p> <pre><code>1. Schedule a meeting\n2. Edit a meeting\n3. Cancel a meeting\n4. Quit\nPlease select an option from the list above\n&gt; 1\n\nYou scheduled a new meeting\n</code></pre>"},{"location":"personal-vision.html","title":"UnixSoft Basic \u2014 Full Summary &amp; Development Plan","text":""},{"location":"personal-vision.html#1-starting-point-applesoft-basic","title":"1. Starting Point: Applesoft BASIC","text":"<ul> <li>Applesoft BASIC features:<ul> <li>Line-numbered, interpreted.</li> <li>Limited data types: mainly numeric (floats by default) and strings.</li> <li>No static typing or type annotations.</li> <li>Control flow uses line numbers for jumps.</li> <li>No native scoping blocks; <code>END</code> keyword terminates program.</li> <li>Dynamic typing with implicit casting.</li> </ul> </li> </ul>"},{"location":"personal-vision.html#2-my-vision-modernizing-applesoft-basic","title":"2. My Vision: Modernizing Applesoft BASIC","text":""},{"location":"personal-vision.html#key-changes-improvements-i-want","title":"Key changes &amp; improvements i want:","text":"<ul> <li>Compiled to native x64 (Linux) assembly, no interpreter or JIT.</li> <li>Static typing with optional type inference and type annotations.</li> <li>Structured control flow using block keywords along with the original line numbers.</li> <li>Introduce block scoping outside control flow for local variables.</li> <li>Add <code>BEGIN</code> / <code>FIN</code> keywords for explicit scope blocks. (think of these like {} in modern languages)</li> <li>Use <code>LET</code> for variable assignments (instead of <code>DIM</code>) but enforce type annotation or assignment.</li> <li>Support true/false keywords for boolean values.</li> <li>Implement type casting rules compatible with static typing.</li> <li>Keep code output efficient and small.</li> <li>Target Linux x64 (System V AMD64 ABI) with plans to possibly support ARM64 in the future.</li> <li>Add IO improvements (better input/output handling more similar to modern libc).</li> </ul>"},{"location":"personal-vision.html#3-ast-and-compiler-architecture","title":"3. AST and Compiler Architecture","text":"<ul> <li>Use an AST node called <code>Scope</code> to represent <code>BEGIN</code> / <code>FIN</code> blocks.</li> <li>Each <code>Scope</code> node holds a list of inner AST nodes (statements).</li> <li>Symbol tables are scoped per <code>Scope</code> node to handle local variables and type checking.</li> <li>Static typing allows:<ul> <li>Compile-time type inference.</li> <li>Type annotations (<code>LET X = 5</code> or <code>LET X AS INTEGER</code> (defaults to 0)).</li> </ul> </li> <li>Codegen:<ul> <li>Allocate stack space per scope.</li> <li>Use native registers (integer: rax, rbx, etc; float: xmm0, xmm1, etc).</li> <li>Compile line numbers to labels if supporting legacy syntax, but aim to move away from line-number-driven flow.</li> </ul> </li> <li>Handle floating-point operations using SSE instructions (<code>movsd</code>, <code>addsd</code>, etc).</li> <li>Pass floats in xmm registers per calling convention.</li> <li>For printing floats, integrate or write float-to-string conversion routines.</li> </ul>"},{"location":"personal-vision.html#4-syntax-suggestions-keywords","title":"4. Syntax Suggestions &amp; Keywords","text":"Feature Keyword(s) Notes/Changes vs Applesoft Variable declaration <code>LET</code> Enforce assignment ortype Block scoping <code>BEGIN</code> / <code>FIN</code> New keywords to define scope blocks Boolean literals <code>TRUE</code>, <code>FALSE</code> Map to 1 and 0 Control flow blocks <code>IF ... THEN BEGIN</code> / <code>FI</code> or <code>FIN</code> Use blocks instead of line jumps, but leaving support for <code>IF ... GOTO</code> End program <code>END</code> Same as Applesoft, terminate program Type annotations <code>LET X AS FLOAT = 5</code> Explicit static typing"},{"location":"personal-vision.html#5-runtime-and-execution","title":"5. Runtime and Execution","text":"<ul> <li>The compiler outputs native x64 assembly.</li> <li>Follow the System V AMD64 calling convention.</li> <li>Stack frames per scope for local variables.</li> <li>Use SSE for float arithmetic.</li> <li>Compile boolean logic with 0/1 values.</li> <li>Provide minimal runtime for IO (input, output) with improvements over Applesoft.</li> <li>Handle float-to-string conversions for printing.</li> </ul>"},{"location":"personal-vision.html#6-development-roadmap","title":"6. Development Roadmap","text":"Step Description Notes Parser Write grammar supporting <code>LET</code>, <code>BEGIN</code>/<code>FIN</code>, <code>IF...THEN...</code>, <code>FI</code>, <code>TRUE</code>, <code>FALSE</code> Define AST nodes (Scope, Let, If, etc) AST Construction Build <code>Scope</code> nodes with nested statements Symbol table stack per scope Type System Implement static typing and type inference Support explicit type annotations Code Generation Compile AST to x64 assembly Manage registers, stack frames, labels Floating-point Support Use SSE instructions for float operations movsd, addsd, etc IO Routines Build or link runtime for input/output Float-to-string, improved console IO Testing Write BASIC test programs Compare against Applesoft behaviors, new features Optimization Keep compiled output small and efficient Reuse registers and stack space"}]}